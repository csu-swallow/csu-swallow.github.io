{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/12/21/hello-world/"},{"title":"test","text":"第一条博客","link":"/2021/12/22/first/"},{"title":"零碎","text":"突然想到的零碎point 在torch中对clone一个张量类似于获得该张量乘1的值，即：x_copy = x.clone() =&gt; x_copy = x &gt;&gt;&gt; import torch &gt;&gt;&gt; import torch.nn as nn &gt;&gt;&gt; a = nn.Parameter(torch.tensor([1.,])) &gt;&gt;&gt; b = nn.Parameter(torch.tensor([4.,])) &gt;&gt;&gt; x = nn.Parameter(torch.tensor([1.,])) &gt;&gt;&gt; x_c = x.clone() &gt;&gt;&gt; x_c tensor([1.], grad_fn=&lt;CloneBackward0&gt;) &gt;&gt;&gt; y = a * x + b * x_c &gt;&gt;&gt; y tensor([5.], grad_fn=&lt;AddBackward0&gt;) &gt;&gt;&gt; y.backward() &gt;&gt;&gt; x.grad tensor([5.]) 说明克隆的结果和原张量并不完全相互独立，克隆出来的结果更像是原张量的乘1结果关于克隆出来的结果与原张量id一致，可参考：https://www.zhihu.com/question/275830564","link":"/2021/12/23/%E9%9A%8F%E7%AC%941/"},{"title":"解决服务器根目录下存储空间不足问题","text":"记录一次大胆的尝试 问题的产生实验室的服务器使用docker和container的模型分配和使用GPU资源，但是由于服务器最初的硬盘分区不够合理，使得2080ti服务器的更目录只有不到80G的空间，并且docker安装在/var目录下（docker的容器包括镜像会产生比较大的空间占用），根目录的空间随时会被占满。因此需要给根目录更多的存储空间。 解决方案我们采取了软链接的方法扩充根目录空间。具体过程记录如下。可能是比较上头，我直接选择了为整个/var文件夹建立软链接。首先，复制/var文件夹内容到空间充足的文件夹(/media/var)下。 sudo cp -r /var /media/var/ 这里使用Tab补全路径的时候没注意多加了/，导致复制之后的路径为/media/var/var。 然后大胆删除/var文件夹（我也不知道怎么这么大胆）， sudo rm -rf /var 这里我忘记先停用docker服务，所以/var文件夹没有删除完。 提心吊胆地重启服务器，因为docker目录内的主体已经删除了，只是有一些overlay2下的文件因为没有停用容器就删除docker导致的错误无法删除，理论上来说，重启之后就可以删除/var文件夹。 sudo reboot 大约半分钟后，服务器重启成功了，但是ssh登录界面极其简介（幸好没有影响到ssh命令），简介到没有任何登入提示（笑），并且此时服务器没有（apt,apt-get,dpkg)，也就是无法以常规方式给服务器安装工具了（慌）。硬着头皮删除/var目录，之后发现在/media下没有/var的备份，在仔细思考和检查之后，发现是硬盘没有自动挂载。设置磁盘开机自动挂载。 sudo blkid /dev/sdb2 #首先查看需要自动挂载的分区的UUID sudo vi /etc/fstab #修改/etc/fstab文件，设置自动挂载 UUID=xxxxxxxxxxxxxxxxxxxxx /media ext4 defaults 0 0 #填入UUID即可，最后两位0 0的意义还不明确，姑且这样用了 然后我们设置软链接，将/media/var/var链接到根目录下 sudo ln -s /media/var/var /var 设置软链接检查无误之后，再次重启服务器 sudo reboot 服务器可以正常登入了，根目录下的使用空间减少了很多，没有根目录爆满的烦恼了，并且docker的镜像和容器也可以正常工作，apt等命令恢复正常（乐）。","link":"/2022/02/24/%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98/"},{"title":"摘抄","text":"摘抄自https://www.bilibili.com/video/BV1WF411b7nt?spm_id_from=333.999.0.0 这种感觉很苦像夏天的风听着很好吹起来却满是燥热她只是途径我留下的星火而我却任凭焚烧了整个荒原连空想都红了眼是有多么遗憾我从未拥有过你一秒可我却像失去你千万次如同夏至的分界线是我一生中最长的那个白天爱慕未停想一直陪着你无论以什么身份我喜欢月亮可月亮并不知道双木非林 田下有心怕她知道 怕她不知道更怕她明明知道又装作不知道过于沉重的东西可能比较适合藏在心里如同无望等待与无悔之间那条模糊的分界线没有开始 没有过程更没有结局你眼里灿若星河可偏偏没有我","link":"/2022/03/07/%E6%91%98%E6%8A%84/"},{"title":"Bug Traiging","text":"任务缺陷分派指的是缺陷报告分派给潜在修复者的传递过程。最理想的情况下，系统可以直接将bug report分派给合适的修复者，在实际的开发过程中，report可能会多次分派，将report从一个修复者分派给另一个修复者的过程被称为Tossing。 数据集分析 2.1 数据集 Eclipse Mozilla Gentoo Eclipse中的bug report样例。除了title和description外，缺陷报告主要包括四种元数据：Status, Assignee, Product, Component。 Status 表明该缺陷报告的解决状态，数据集由标记为”Fixed”的缺陷报告组成； Assignee 指出谁在负责修复缺陷； Product&amp;Component 缺陷涉及的产品和产品内的组件。 bug 历史记录记载了缺陷报告的历史变化，每一次变化可以用(who, when, what, removed, added)的元组表示。 2.2 可行性 统计收集数据中的缺陷报告的报告者的局部性（reporter locality），作者将Product和Component域信息组合作为子区域，统计了数据集中的每个repoter涉及到的子区域的数量。 2.3 tossing 序列 模型的改进方向 构建开发者关系图，绘制开发者画像","link":"/2022/05/20/Bug%20Triaging%20Based%20on%20Tossing%20Sequence%20Modeling/"},{"title":"常用git命令","text":"基本命令 命令名称 作用 git config --global user.name 用户名 设置用户签名 git config --global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 添加到暂存区 git commit -m &quot;日志信息&quot; 文件名 提交到本地库 git reflog 查看历史记录 git reset --hard 版本号 版本穿梭 git rm --cached 文件名 删除暂存区文件 branch（分支命令） 命令 作用 git branch &lt;分支名&gt; 创建分支 git branch -v 查看分支 git merge &lt;分支名&gt; 把指定的分支合并到当前分支上 git branch -m &lt;old_name&gt; &lt;new_name&gt; 重命名 git checkout &lt;分支名&gt; 切换分支 git checkout -b &lt;分支名&gt; 创建并切换分支 远程仓库 命令 作用 git remote -v 查看当前所有远程仓库别名 git remote add 别名 远程仓库 起别名 git remote rename &lt;old_name&gt; &lt;new_name&gt; 重命名 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 推送本地分支上的内容到远程仓库 git clone 远程地址 将远程仓库的内容克隆到本地 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 将远程仓库对应分支最新内容拉取下来后与当前本地分支直接合并","link":"/2022/05/20/git/"},{"title":"BertTokenizer","text":"BertTokenizer使用方式 pad_to_max_length argument is deprecated and will be removed in a future version, use padding=True or padding='longest' to pad to the longest sequence in the batch, or use padding='max_length' to pad to a max length. In this case, you can give a specific length with max_length (e.g. max_length=45) or leave max_length to None to pad to the maximal input size of the model (e.g. 512 for Bert). from transformers import BertTokenizer token = BertTokenizer.from_pretrained('hfl/chinese-roberta-wwm-ext') token([('你好', '氨基酸'), ('中南大学', '清华大学')],padding=True) # {'input_ids': [[101, 872, 1962, 102, 3710, 1825, 7000, 102, 0, 0, 0], [101, 704, 1298, 1920, 2110, 102, 3926, 1290, 1920, 2110, 102]], 'token_type_ids': [[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]], 'attention_mask': [[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]} token([('你好', '氨基酸'), ('中南大学', '清华大学')],padding='max_length', max_length=15) # {'input_ids': [[101, 872, 1962, 102, 3710, 1825, 7000, 102, 0, 0, 0, 0, 0, 0, 0], [101, 704, 1298, 1920, 2110, 102, 3926, 1290, 1920, 2110, 102, 0, 0, 0, 0]], 'token_type_ids': [[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]], 'attention_mask': [[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]]} # decode接收单个id序列，解码为字符串 token.decode([101, 872, 1962, 102, 3710, 1825, 7000, 102, 0, 0, 0]) # '[CLS] 你 好 [SEP] 氨 基 酸 [SEP] [PAD] [PAD] [PAD]' # tokenizer和encode接收string或者字符序列 token.tokenize(&quot;你好&quot;) # ['你', '好'] token.encode(&quot;你好&quot;) # [101, 872, 1962, 102]","link":"/2022/12/09/BertTokenizer/"},{"title":"java和python继承的区别","text":"java继承表现出子类对象中包含一个父类对象的特点，当父类和子类中声明了相同变量时，父类函数固执地调用父类变量，子类函数固执地调用子类变量；而python不存在类型声明，因此没有这样的问题，使得变量在子类对象中只存在一个 但是如果将java继承中的变量问题类比成全局变量和局部变量就很好理解：父类变量为全局变量，子类中声明相同变量相当于局部变量隐藏了全局变量，并且在“局部”内的所有方法都使用局部变量，而“外部”的方法使用全局变量；当局部没有声明相同变量，直接修改全局变量，其他使用该变量的位置也会做出相应的改变","link":"/2022/12/16/java%E5%92%8Cpython%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"matplotlib绘图","text":"最近复习了《利用python进行数据分析》一书，主要回顾绘图工具的使用方法和数据处理接口。 matplotlib绘图的不同方式以热力图和折线图为例，体现面向对象的绘图方式和pyplot接口的不同，理论上面向对象的绘图方式是更推荐的使用方法 数据准备 import matplotlib.pyplot as plt import numpy as np data1 = np.random.randn(100, 100).cumsum(0) data2 = np.random.randn(10).cumsum() plot方法 plt.figure(figsize=(15, 5)) plt.subplot(121) plt.imshow(data1, ) plt.colorbar() plt.grid(True) plt.xlabel(&quot;test_x&quot;) plt.ylabel(&quot;test_y&quot;) plt.subplot(122) plt.plot(data2) plt.xlim((0,12)) plt.ylim((-2,5)) plt.xticks([0,1,2,3,4,5,6,7,8,9,10,11,12], ['q','w','e','r','t','y','u','i','o','p','a','s','d']) plt.show() 结果： 面向对象接口 fig, axes = plt.subplots(1,2,figsize=(15,5), facecolor='w') # 通常设置subplot分布时，返回的axessize是等同于给定的行列数的，即返回axes的二维数组， # 但是当行或者列为1时，返回的是一维axes数据 im = axes[0].imshow(np.random.randn(100,100).cumsum(0)) fig.colorbar(im, ax=axes[0]) axes[0].grid(True) axes[0].set_xlabel(&quot;test_x&quot;) axes[0].set_ylabel(&quot;test_y&quot;) axes[1].plot(data2) axes[1].set_xlim((0,12)) axes[1].set_ylim((-2,5)) axes[1].set_xticks([0,1,2,3,4,5,6,7,8,9,10,11,12]) axes[1].set_xticklabels(['q','w','e','r','t','y','u','i','o','p','a','s','d']) plt.show() 结果： 未完待续。。。","link":"/2023/03/26/matplotlib%E7%BB%98%E5%9B%BE/"},{"title":"python模块变量导入与修改","text":"CSDN参考做过相似的实验懒得写了，参考上文","link":"/2023/03/27/python%E6%A8%A1%E5%9D%97%E5%8F%98%E9%87%8F%E5%AF%BC%E5%85%A5%E4%B8%8E%E4%BF%AE%E6%94%B9/"}],"tags":[{"name":"test","slug":"test","link":"/tags/test/"},{"name":"test2","slug":"test2","link":"/tags/test2/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"现代诗","slug":"现代诗","link":"/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"}],"categories":[{"name":"test","slug":"test","link":"/categories/test/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"摘抄","slug":"摘抄","link":"/categories/%E6%91%98%E6%8A%84/"}]}